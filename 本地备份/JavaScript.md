- Event Loop事件轮询机制
- 如何判断手机端还是PC
- 箭头函数与普通函数的区别？本质区别是什么？
- Promise的理解
- let、const和var的区别
- 用过promise吗？它的使用是为了解决一个什么问题？promise底层是怎么设计的？
- 你能说一下闭包的优缺点吗？
- 内存泄漏和内存溢出有什么区别？
- 说一下原型链的理解？
- 原型链__proto__这个隐式属性的实现原理是怎样的？
- 为什么用jsx进行开发组件库？有什么好处？
  - 增加可读性和可维护性：JSX 让代码看起来更像是 HTML 模板，这使得代码更容易阅读和理解，也更容易进行修改和维护。
  - 提高开发效率：使用 JSX 可以减少开发者在编写组件时需要编写的模板代码，这可以减少代码量，提高开发效率。
  - 更好的性能：JSX 可以通过使用虚拟 DOM 来优化组件渲染性能。React 在每次组件更新时会生成新的虚拟 DOM 树，并与旧的虚拟 DOM 树进行比较，然后只更新需要更新的部分，从而提高渲染效率。
  - 易于与 React 集成：React 是一种流行的前端框架，使用 JSX 可以使组件库更容易与 React 集成，从而提高组件库的适用性。
- Tree Shaking 的原理，CommonJS能用吗，Tree Shaking 有什么副作用吗？





## 基本类型

在js中共有8中基本类型，分别为：undefined、null、Boolean、Number、String、Object、Symbol、BigInt

值类型是直接存储在栈中的简单数据段，占据空间小，大小固定

### number类型

在JavaScript中存储数据是基于IEEE-754标准存储的双精度浮点数类型。双精度浮点数总共有64位，第一位表示符号，接着11位表示阶码，剩余的52位表示尾数

#### 为什么0.1+0.2不等于0.3？

- 进制转换：js在做数字计算的时候，0.1和0.2都会被转成二进制后无限循环，但是js采用的IEEE754二进制浮点计算，最大可以存储53位有效数字，于是大于53位后面的会被全部截掉，将导致精度丢失
- 对阶运算：由于指数位不相同，运算时需要对阶运算，阶数小的尾数要根据阶差来右移，尾数位移时可能会发生数丢失的情况，影响精度



## 原型

- 原型：每一个JavaScript对象（null除外）在创建的时候就会与之关联到另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性，其实就是`prototype`对象
- 原型链：由相互关联的原型组成的链状结构

## 作用域与作用域链

作用域是指程序源代码中定义变量的区域

作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限

- 作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。作用域决定了代码区块中变量和其他资源的可见性
- 作用域链：从当前作用域开始一层层往上找某个变量，直到全局作用域，这种层次关系就是作用域链

JavaScript中的作用域是静态作用域，函数的作用域在函数定义时就确定了

### 作用域与执行上下文

JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段

**解释阶段：**

- 词法分析
- 语法分析
- 作用域规则确定

**执行阶段**

- 创建执行上下文
- 执行函数代码
- 垃圾回收

JavaScript解释阶段就会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。

作用域和执行上下文最大的区别就是：**执行上下文在运行时确定，随时可以改变；作用域在定义时就确定，并且不会改变**

同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值

### 执行上下文

JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析。当执行一段代码的时候，会进行一个“准备工作”

每一个执行上下文，都有三个重要属性：

- 变量对象（VO）
- 作用域链
- this

#### 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明

变量对象会包括：

- 函数的所有形参
- 函数声明
- 变量声明

#### 闭包

> 在JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，可以在一个内层函数中访问到其外层函数的作用域

## const和let

使用let或者const可以声明块级作用域，在此之间：

- 声明变量不会提升到代码块顶部
- 禁止重复声明

### 变量提升

「为什么会有变量提升？」

由于第一代JS虚拟机中的抽象纰漏导致的，编译器将变量放到了栈槽内并编入索引，然后在（当前作用域的）入口处将**变量名**绑定到了**栈槽内**的变量。（注：这里提到的抽象是计算机术语，是对内部发生的更加复杂的事情的一种简化。）

「为什么会有函数提升？」

函数提升是为了解决函数互相调用的问题





## EventLoop

在JavaScript执行过程中

- 同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步的进入Event Table并注册函数
- 当指定的事情完成时，Event Table会将这个函数移入Event Queue
- 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行
- 上述过程会不断重复

在JavaScript执行过程中，会先完成执行栈中的任务，之后将微任务和宏任务分别推进各自的队列中，然后按照微任务-宏任务-微任务的顺序继续调用；在此期间如果触发网络请求、定时器、浏览器事件（click、mouse）等，会将回调任务加入到任务队列中，再从任务队列中按个执行

详细的执行流程如下：

1. 从任务队列中取出一个宏任务并执行
2. 检查微任务队列，执行并清空微任务队列，如果再微任务的执行中又加入了新的微任务，也会在这一步一起执行
3. 进入更新渲染阶段，判断是否需要渲染，这里有一个`renderingopportunity`的概念，也就是说不一定每一轮event loop都会对应一次浏览器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，通常来说这个渲染间隔是固定的
   - 浏览器会尽可能的保持帧率稳定
   - 如果浏览器上下文不可见，那么页面会降低到4fps左右甚至更低
   - 如果满足以下条件，也会跳过渲染：
     1. 浏览器判断更新渲染不会带来视觉上的改变
     2. 帧动画回调为空
4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行
5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的`resize`方法
6. 对于需要渲染的文档，如果页面发生了滚动，执行`scroll`方法
7. 对于需要渲染的文档，执行帧动画回调，也就是`requestAnimationFrame`的回调
8. 对于需要渲染的文档，执行`IntersectionObserver`的回调
9. 对于需要渲染的文档，重新渲染绘制用户界面
10. 判断task队列和microTask队列是否都为空，如果是的话，则进行`Idle`空闲周期的算法，判断是否要执行`requestIdleCallback`的回调函数

对于`resize`和`scroll`来说，并不是到了这一步才去执行滚动和缩放，那岂不是要延迟很多。浏览器当然会立刻帮你滚动视图，根据`CSSOM 规范`所讲，浏览器会保存一个`pending scroll event targets`，等到事件循环中的`scroll`这一步，去派发一个事件到对应的目标上，驱动它去执行监听的回调函数而已。`resize`同理



### 宏任务和微任务

进程的切换肯定是宏任务，因为需要花费大量的资源

线程的切换是微任务，因为只需要在同一个进程中切换就可以了

#### 为什么和定时器有关的任务都是宏任务？

因为计时是实时的，一定不能被阻塞，所以定时器被设计在另一个进程中被管理，所以，定时器任务会有进程的切换

### 任务队列

事件循环中可能会有一个或多个任务队列，这些队列分别为了处理：

1. 鼠标和键盘事件
2. 其他的一些task

浏览器会在保持任务顺序的前提下，可能分配四分之三的优先权给鼠标和键盘事件，保证用户的输入得到最高优先级的响应，而剩下的优先级交给其他Task

#### requestAnimationFrame

requestAnimationFrame的回调有两个特征：

1. 在重新渲染之前调用
2. 很可能在宏任务之后不调用

#### requestIdleCallback

> 将一些计算量较大但是又没那么紧急的任务放到空闲时间去执行

##### 渲染有序进行

有序的`浏览器->用户->浏览器->用户`的调度是基于一个前提的，就是我们要把任务切分成比较小的片。

##### 渲染长期空闲

有可能在几帧的时间内浏览器都是空闲的，并没有发生任何影响视图的操作，那么就不需要绘制页面；这种情况下为什么还是会有`50ms`的`deadline`？是因为浏览器为了提前应对一些可能会突发的用户交互操作，比如用户输入文字。如果给的时间太长了，任务就会把主线程卡住，用户的交互操作就得不到回应。50ms可以确保用户在无感知的延迟下得到回应

#### 总结

1. 事件循环不一定每轮都伴随着重渲染，如果有微任务，一定会伴随着微任务执行
2. 决定浏览器视图是否渲染的因素很多，浏览器非常聪明
3. `requestAnimationFrame`在重新渲染之前执行
4. `requestIdleCallback`在渲染屏幕之后执行，并且是否有空执行看浏览器的调度

## Promise

Promise是异步编程的一种解决方案

所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件的结果。

Promise对象有两个特点：

1. 对象的状态不受外界影响
2. 一旦状态改变，就不会再变

相应的，Promise也有一些缺点：

- 无法取消Promise，一旦新建就会立即执行，无法中途取消
- 如果不设置回调函数，内部抛出的错误，不会反应到外部
- 当处于pending状态时，无法得知目前进展到哪一个阶段

## Iterator

> 为所有数据结构，提供了一种统一的访问机制，即for...of循环

一种数据结构只要部署了Iterator接口，就可以认为这种数据结构是“可遍历的”



## 名词

- `词法作用域`：函数的作用域在函数定义的时候就决定了
- `动态作用域`：函数调用的时候才决定的

## 相关链接

- [深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）](https://juejin.cn/post/6844904165462769678)
- [硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准](https://juejin.cn/post/6940405970954616839)