- axios和ajx的区别
- 正向代理和反向代理的区别？
- TCP协议三次握手、四次挥手的过程，为什么挥手要4次？
- webSocket与传统的http相比有什么优势？
- 简单请求和非简单请求的区别。
- 使用 HTTPS 一定是安全的吗？





## TCP/IP协议族

TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层：应用层、传输层，网络层和数据链路层





### TCP/IP通信传输流

1. 作为发送端的客户端在应用层（HTTP协议）发出一个想看某个web页面的HTTP请求
2. 为了方便传输，在传输层（TCP协议）把从应用层出收到的数据（HTTP请求报文）进行分割，并在每个报文上打上标记序号及端口号后转发给网络层
3. 在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层



## 七层网络模型

- 应用层
- 会话层
- 表示层
- 传输层
- 网络层
- 数据链路层
- 物理层

## 应用层

> 决定了向用户提供应用服务时通信的活动

应用：FTP，DNS服务，HTTP协议

### HTTP协议

从协议版本来分：

- HTTP0.9
- HTTP1.0
- HTTP1.1
  - 块传输
  - 身份验证
  - 缓存处理，例如 Cache-Control
  - 更多的响应码
  - 主机头字段
  - 管道化：允许客户端同时发送多个请求

特点：默认连接都是持久连接，当服务器端明确断开连接时，需要指定`Connection`首部字段的值为Close

- HTTP2.0
- HTTPS

特点：HTTPS比HTTP要慢2至100倍

SSL的慢分两种。一种是通信慢，另一种是由于大量消耗CPU及内存等资源，导致处理速度变慢

**为什么不一直用https？**

1. 与纯文本通信相比，加密通信会消耗更多的CPU及内存资源
2. 节约购买证书的开销

#### 报文主体和实体主体的差异

- 报文：HTTP通信中的基本单位，由8位字节流组成，通过HTTP通信传输
- 实体：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成

通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异

#### 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体

常见内容编码方式：

- gzip
- compress
- deflate
- identity

#### 分割发送的分块传输编码

在HTTP通信过程中，请求的编码实体资源尚未全部完成传输之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为**分块传输编码**

#### 获取部分内容的范围请求

所谓恢复就是指能从之前下载中断处恢复下载；

要实现该功能需要指定下载的实体范围，像这样指定范围发送的请求叫做范围请求

#### HTTP的不足

- 通信使用明文，内容可能会被窃听
- 不验证通信方的身份，有可能遭遇伪装
- 无法证明报文的完整性，有可能已遭篡改

按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视

## 会话层



## 表示层



## 传输层

>提供处于网络连接中的两台计算机之间的数据传输

应用：TCP、UDP

### TCP

> 提供可靠的字节流服务

所谓的字节流服务是指为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理

可靠的传输服务是指能够把数据准确可靠的传给对方

## 网络层

> 用来处理在网络上流动的数据包，**数据包是网络传输的最小数据单位**。在该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。

### IP协议

把各种数据包传送给对方；而要保证确实传送到对方那里，则需要满足各类条件，其中两个重要的条件就是IP地址和MAC地址

IP地址可以和MAC地址进行配对，IP地址可变换，但MAC地址基本不会更改

IP间的通信依赖MAC地址。ARP是一种用以解析地址的协议，根据通信方的IP地址就可以反查出MAC地址

## 数据链路层

> 用来处理连接网络的硬件部分，包括控制操作系统、硬件的设备驱动、NIC，及光纤等物理可见部分



## 物理层







## 身份认证



HTTP/1.1使用的认证方式：

- BASIC认证
- DIGEST认证
- SSL客户端认证
- FormBase认证

### BASIC认证

从HTTP/1.0就定义的认证方式。

1. 当请求的资源需要BASIC认证时，服务器会返回401 Authorization Required，返回带WWW-Authenticate首部字段的响应
2. 接收到状态码401的客户端为了通过BASIC认证，需要将用户ID及密码发送给服务器，发送的字符串内容会经过Base64编码处理
3. 接收到包含首部字段Authorization请求的服务器，会对认证信息的正确性进行验证

BASIC认证使用上不够便捷灵活，且达不到多数Web网站期望的安全性等级，因此并不常用

### DIGEST认证

为了弥补BASIC认证存在的弱点，从HTTP/1.1起就有了DIGEST仁恒。DIGEST认证同样使用质询/响应的方式，但不会像BASIC认证那样直接发送明文密码

质询响应方式就是指一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码，最后将响应码返回给对方进行认证的方式



## SPDY



SPDY没有完全改写HTTP协议，而是在TCP/IP的应用层与传输层之间通过新加会话层的形式运作。同时考虑到安全性问题，SPDY规定通信中使用SSL

使用SPDY后：

- 多路复用
- 赋予请求优先级
- 压缩HTTP首部
- 推送功能
- 服务器提示功能

## 状态码

- `200 OK`：表示从客户端发来的请求在服务端被正常处理了
- `204 No Content`：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分
- `206 Patial Content`：客户端进行了范围请求
- `301 Moved Permanently`：永久性重定向
- `302 Found`：临时性重定向
- `304 Not Modified`：读取缓存
- `400 Bad Request`：请求报文中存在语法错误
- `401 Unauthorized`：发送的请求需要有通过HTTP认证的认证信息
- `403 Forbidden`：对请求资源的访问被服务器拒绝了
- `404 Not Found`：服务器上无法找到请求的资源
- `500 Internal Server Error`：服务器在执行请求时发生了错误
- `503 Service Unavailable`：服务器暂时处于超负载或正在进行停机维护

## 信息存储

### cookie

每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。

Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。

**Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。session实际是一个抽象的概念**

### session

由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。

**Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；**



### https数据传输过程

```
客户端向服务器发起 HTTPS 请求，请求中包含了 SSL/TLS 支持的信息，比如支持的 SSL/TLS 版本号、加密算法等。

服务器返回证书给客户端，证书中包含了服务器的公钥、服务器的身份信息和证书的有效期等。

客户端验证服务器的身份，包括验证证书的有效性、证书是否过期、证书中的域名与服务器的域名是否一致等。

如果证书验证通过，客户端生成一个随机的加密密钥，并使用服务器的公钥进行加密，然后发送给服务器。

服务器使用私钥解密客户端发来的密钥，然后生成一个随机数作为会话密钥，并将会话密钥加密后发送给客户端。

客户端和服务器使用会话密钥进行数据传输，客户端和服务器之间的所有数据都使用会话密钥进行加密和解密，保证数据的机密性和完整性
```



## 基本名词

- `协议`：计算机与网络设备要相互通信，双方必须基于相同的方法；不同的硬件、操作系统之间的通信，所有的一切都需要的一种规则
- `IP地址`：节点被分配到的地址
- `Mac地址`:网卡所属的固定地址
- `代理`：一种有转发功能的应用程序
- `网关`：转发其他服务器通信数据的服务器
- `隧道`：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序

