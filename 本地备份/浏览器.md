- 如何做静态资源缓存
- SSR服务端渲染的理解
- 浏览器缓存的方式有哪些？
- 域名解析过程是怎样的？
- 设置cookie的domain用来实现什么功能？





浏览器的主要构成部分：

- 用户界面
- 浏览器引擎
- 渲染引擎
- 网络
- JS执行器
- UI后端
- 数据存储

## 多进程的浏览器

浏览器是多进程的，其中有一个主进程，然后每开一个tab就是一个进程

进程包括：

- Browser进程
- 第三方插件进程
- GPU进程
- 浏览器渲染进程

单个进程是多线程的：

- GUI线程
- JS引擎线程
- 事件触发线程
- 定时器线程
- 网络请求线程

在浏览器内核拿到内容后，渲染步骤：

1. 解析HTML，构建DOM
2. 解析CSS，构建CSS规则树
3. 合并DOM树和CSS树，生成render树
4. 布局render树，负责各元素尺寸，位置计算
5. 绘制render树，绘制页面像素信息

### 解析HTML，构建DOM

1. 浏览器将获得的HTML内容（Bytes）基于他的编码转换为单个字符
2. 浏览器按照HTML规范标准将这些字符转换为不同的标记token。每个token都有自己独特的含义以及规则集
3. 分词的结果是得到一堆的token，此时把他们转换为对象，这些对象分别定义他们的属性和规则
4. 因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样

### 解析CSS，构建CSS规则树

```
Bytes → characters → tokens → nodes → CSSOM
```

### 合并DOM树和CSS树，生成render树

一般来说，渲染树和DOM树相对应的，但不是严格意义上的一一对应,因为有一些不可见的DOM元素不会插入到渲染树中，如head这种不可见的标签或者display: none等

### 布局render树，负责各元素尺寸，位置计算

布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸。

### 绘制render树，绘制页面像素信息

绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。

- Layout，也称为Reflow，即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树

- Repaint，即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了



### 总结

首先输入一个网址，浏览器会向服务器发起DNS请求，得到对应的IP地址（会被缓存一段时间，后续访问就不用再去向服务器查询）。之后会进行TCP三次握手与服务器建立连接，连接建立后，浏览器会代表用户发送一个初始的GET请求，通常是请求一个HTML文件。服务器收到对应请求后 ，会根据相关的响应头和HTML内容进行回复。

一旦浏览器拿到了数据，就会开始解析信息，这个过程中，浏览器会根据HTML文件去构建DOM树，当遇到一些阻塞资源时（如同步加载的script标签）会去加载阻塞资源而停止当前DOM树构建（所以能够异步的或延迟加载的就尽量异步或延迟，同时页面的脚本还是越少越好）。在构建DOM树时，浏览器的主线程被占据着，不过浏览器的预加载扫描器会去请求高优先级的资源（如css、js、字体），预加载扫描器很好的优化了阻塞问题。接下来浏览器会处理CSS生成CSSDOM树，将CSS规则转换为可以理解和使用的样式映射，这个过程非常快（通常小于一次DNS查询所需时间）。有了DOM树和CSSDOM树，浏览器会将其组合生成一个Render树，计算样式或渲染树会从DOM的根节点开始构建，遍历每一个可见节点（将相关样式匹配到每一个可见节点，并根据CSS级联去的每个节点的计算样式）。接下来开始布局，该过程（依旧是从根节点开始）会确定所有节点的宽高和位置，最后通过渲染器将其在页面上绘制。绘制完成了，并不代表交互也都生效了，因为主线程可能还无法抽出时间去处理滚动、触摸等交互，要等到js加载完成，同时主线程空闲了整个页面才是正常可用的状态。

## 浏览器渲染

### 重绘和重排

- 重排：无论通过什么方式影响了元素的几何信息，浏览器需要重新计算元素在视口内的集合属性
- 重绘：将渲染树的每个节点都转换为屏幕上的实际像素

**减少重排和重绘？**

- 最小化重绘和重排
- 批量操作DOM
- 使用absolute或fixed使元素脱离文档流
- 开启GPU加速

**什么时候发生回流重绘**

- 添加或删除可见的DOM元素
- 元素的位置发生变化
- 元素的尺寸发生变化
- 内容发生变化
- 页面一开始渲染的时候
- 浏览器的窗口尺寸变化

**回流一定会触发重绘，重绘不一定会回流**

### 浏览器优化机制

由于每次重排都会造成额外的计算消耗，因此大多树浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，知道一段时间或者操作达到一个阈值，才清空队列。当你获取布局信息的操作的时候，会强制队列刷新。

- offsetTop/offsetLeft/offsetWidth/offsetHeight
- scrollTop/scrollLeft/scrollWidth/scrollHeight
- clientTop/clientLeft/clientWidth/clientHeight
- getComputedStyle
- getBoundingClientRect

### CSS3硬件加速的坑

- 如果太多使用css3硬件加速，会导致内存占用较大，会有性能问题
- 在GPU渲染字体会导致抗锯齿无效

## 垃圾回收机制（[link](https://juejin.cn/post/6981588276356317214)）

GC是`Garbage collection`，其作用就是负责回收垃圾的。

在JavaScript内存管理中有一个概念叫做`可达性`，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收

JavaScript垃圾回收机制的原理就是定期找出那些不再用到的内存（变量），然后释放内存

两种最常见的方式：

- 标记清除算法
- 引用计数算法

### 标记清除算法

目前在JavaScript引擎里这种算法是最常用的，只是各大浏览器厂商还对此算法进行了优化加工

标记阶段即为所有活动对象做上标记，清除阶段则把没有标记的销毁

#### 优点

实现比较简单

#### 缺点

清除之后，剩余的对象内存位置是不变的，会导致空闲内存是不连续的，出现内存碎片，并且由于剩余空间内存不是整块，它是由不同大小内存组成的内存列表；分配速度慢

### 引用计数算法

#### 优点

对比标记清除更加清晰，在引用计数的引用值为0时回收。

#### 缺点

占据的空间；无法解决循环引用无法回收的问题；

### V8中的GC

在V8中将堆内存分为了新生代和老生代两个区域，采用不同的垃圾回收器

新生代的对象存活时间较短的对象，通常只支持1~8M的容量；而老生代的对象为存活时间较长或常驻内存的对象，容量通常比较大

#### 新生代

新生代对象是通过一个名为`Scavenge`的算法进行垃圾回收，在`Scavenge算法`的具体实现中，主要采用了一种复制式的方法即`Cheney算法`

`Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

#### 老生代

老生代中的垃圾回收方式就是标记清除算法

首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象

清除阶段老生代垃圾回收器会直接将非活动对象清除掉



## 存储

### cookie

用于浏览器和服务器的通讯

#### 缺点

- 存储大小为4kb
- http请求时需要发送到服务器，增加了请求数量
- 只能用document.cookie来修改

### localStorage & sessionStorage

- HTML5专为存储设计，最大可存5M
- API简单易用
- 不会随着http请求发送到服务端





## 跨域

产生原因：浏览器同源策略

解决办法：

- 配置nginx反向代理
- jsonp
- 图片
- 设置CORS
- 利用iframe
- websocket

